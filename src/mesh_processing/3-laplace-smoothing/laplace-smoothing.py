'''
2024 Graphics Programming Final Project
Animating an object from single monocular video

name: laplace-smoothing.py
description: 
reference: This script performs Laplace smoothing on a mesh object in Blender to improve 
surface quality by reducing irregularities or noise generated by Gaussian splatting and K-Planes. 
It offers various preservation methods to maintain important geometric features such as volume or 
tangential directions while smoothing the surface.

reference: https://onlinelibrary.wiley.com/doi/epdf/10.1111/1467-8659.00334

how to use:
    1. Open Blender file
    2. Open the Python Console
    3. Open the script file on the Python Console
    4. *** Select a mesh object in the 3D Viewport, Object mode before running the script ***
    5. Run the script
'''

import bpy
import bmesh
from mathutils import Vector

def laplace_smooth(obj, iterations=1, lambda_factor=0.5, preservation_method='none'):
    """
    Perform Laplace smoothing with optional volume preservation.

    obj: The mesh object to smooth.
    iterations: Number of smoothing iterations.
    lambda_factor: Smoothing factor (0 < lambda_factor < 1).
    preservation_method: Preservation method ('none', 'centroid', 'local_volume', 'tangential').
    """
    if obj.type != 'MESH':
        print(f"{obj.name} is not a mesh object!")
        return

    bm = bmesh.new()
    bm.from_mesh(obj.data)

    for _ in range(iterations):
        # Store original vertex positions
        vertex_positions = {v: v.co.copy() for v in bm.verts}

        if preservation_method == 'centroid':
            # Compute the centroid of the mesh
            centroid = sum((v.co for v in bm.verts), Vector()) / len(bm.verts)

        for v in bm.verts:
            if not v.is_boundary:  # Skip boundary vertices
                # Calculate the average position of neighboring vertices
                neighbors = [e.other_vert(v) for e in v.link_edges]
                if len(neighbors) == 0:
                    continue

                avg_position = sum((vertex_positions[n] for n in neighbors), Vector()) / len(neighbors)

                # Apply Laplace smoothing
                smoothed_position = (1 - lambda_factor) * v.co + lambda_factor * avg_position

                if preservation_method == 'centroid':
                    # Adjust for global centroid-based volume preservation
                    v.co = smoothed_position + (v.co - centroid) * (1 - lambda_factor) * 0.001
                elif preservation_method == 'local_volume':
                    initial_volume = calculate_local_volume(v, neighbors, vertex_positions)

                    new_position = smoothed_position
                    new_volume = calculate_local_volume(v, neighbors, vertex_positions, new_position)

                    if initial_volume > 0:  # Ensure initial volume is valid
                        if new_volume > 0:
                            volume_ratio = min(1.0, new_volume / initial_volume)
                        else:
                            volume_ratio = 0.0
                    else:
                        volume_ratio = 1.0

                    v.co = v.co.lerp(new_position, volume_ratio)
                elif preservation_method == 'tangential':
                    # Restrict movement to the tangential plane
                    normal = v.normal
                    movement_vector = smoothed_position - v.co
                    tangential_movement = movement_vector - movement_vector.dot(normal) * normal
                    v.co += 0.1*tangential_movement
                else:
                    # No preservation, standard Laplace smoothing
                    v.co = smoothed_position

    bm.to_mesh(obj.data)
    bm.free()
    print(f"Laplace smoothing with {preservation_method} preservation applied to {obj.name} for {iterations} iterations.")

def calculate_local_volume(vertex, neighbors, vertex_positions, position=None):
    """
    Calculate the local volume as the sum of tetrahedral volumes formed by the vertex, neighbors, and the origin.

    vertex: The vertex being smoothed.
    neighbors: List of neighboring vertices.
    vertex_positions: Dictionary of original vertex positions.
    position: Optional position to use for the vertex instead of its current location.
    """
    if position is None:
        position = vertex.co  # Default to the current position

    volume = 0.0
    origin = Vector((0, 0, 0))  # Assume the origin for simplicity

    for n in neighbors:
        # Calculate tetrahedron volume using vertex, neighbor, and the origin
        v1 = position
        v2 = vertex_positions[n]
        tetra_volume = abs((v1 - origin).cross(v2 - origin).dot(v2 - v1)) / 6.0
        volume += tetra_volume

    return volume


if __name__ == "__main__":
    obj = bpy.context.active_object

    if obj:
        laplace_smooth(obj, iterations=10, lambda_factor=0.5, preservation_method='none')
    else:
        print("No active object selected!")