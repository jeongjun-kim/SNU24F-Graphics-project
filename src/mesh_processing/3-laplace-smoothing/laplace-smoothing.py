'''
2024 Graphics Programming Final Project
Animating an object from single monocular video

name: laplace-smoothing.py
description: 
reference: This script performs Laplace smoothing on a mesh object in Blender to improve 
surface quality by reducing irregularities or noise generated by Gaussian splatting and K-Planes. 
It offers various preservation methods to maintain important geometric features such as volume or 
tangential directions while smoothing the surface.

reference: https://onlinelibrary.wiley.com/doi/epdf/10.1111/1467-8659.00334

how to use:
    1. Open Blender file
    2. Open the Python Console
    3. Open the script file on the Python Console
    4. *** Select a mesh object in the 3D Viewport, Object mode before running the script ***
    5. Run the script
'''

import bpy
import bmesh
from mathutils import Vector

def laplace_smooth(obj, iterations=1, lambda_factor=0.5, preservation_method='none'):
    """
    Perform Laplace smoothing with optional volume preservation.

    obj: The mesh object to smooth.
    iterations: Number of smoothing iterations.
    lambda_factor: Smoothing factor (0 < lambda_factor < 1).
    preservation_method: Preservation method ('none', 'centroid', 'local_volume', 'tangential').
    """
    if obj.type != 'MESH':
        print(f"{obj.name} is not a mesh object!")
        return

    bm = bmesh.new()
    bm.from_mesh(obj.data)

    for _ in range(iterations):
        # Store original vertex positions
        vertex_positions = {v: v.co.copy() for v in bm.verts}

        if preservation_method == 'centroid':
            # Compute the centroid of the mesh
            centroid = sum((v.co for v in bm.verts), Vector()) / len(bm.verts)

        for v in bm.verts:
            if not v.is_boundary:  # Skip boundary vertices
                # Calculate the average position of neighboring vertices
                neighbors = [e.other_vert(v) for e in v.link_edges]
                if len(neighbors) == 0:
                    continue

                avg_position = sum((vertex_positions[n] for n in neighbors), Vector()) / len(neighbors)

                # Apply Laplace smoothing
                smoothed_position = (1 - lambda_factor) * v.co + lambda_factor * avg_position

                if preservation_method == 'centroid':
                    # Adjust for global centroid-based volume preservation
                    v.co = smoothed_position + (v.co - centroid) * (1 - lambda_factor) *0.001
                elif preservation_method == 'local_volume':
                    # Calculate local volume before smoothing
                    initial_volume = calculate_local_volume(v, neighbors)

                    # Apply smoothing and calculate new volume
                    v.co = smoothed_position
                    new_volume = calculate_local_volume(v, neighbors)

                    # Adjust to maintain local volume
                    volume_ratio = initial_volume / new_volume if new_volume != 0 else 1
                    v.co = v.co.lerp(smoothed_position, volume_ratio)
                elif preservation_method == 'tangential':
                    # Restrict movement to the tangential plane
                    normal = v.normal
                    movement_vector = smoothed_position - v.co
                    tangential_movement = movement_vector - movement_vector.dot(normal) * normal
                    v.co += tangential_movement
                else:
                    # No preservation, standard Laplace smoothing
                    v.co = smoothed_position

    bm.to_mesh(obj.data)
    bm.free()
    print(f"Laplace smoothing with {preservation_method} preservation applied to {obj.name} for {iterations} iterations.")

def calculate_local_volume(vertex, neighbors):
    """
    method for local volume preservation method.
    Calculate the local volume (or area in 2D) around a vertex.

    vertex: The vertex being smoothed.
    neighbors: List of neighboring vertices.
    """
    volume = 0.0
    for n in neighbors:
        volume += (vertex.co - n.co).length
    return volume

if __name__ == "__main__":
    obj = bpy.context.active_object

    if obj:
        laplace_smooth(obj, iterations=10, lambda_factor=0.5, preservation_method='none')
    else:
        print("No active object selected!")